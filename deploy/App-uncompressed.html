<!DOCTYPE html>
<html>
<head>
    <title>portfolio-timesheet-export</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.3.1/moment.min.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                var app = null;

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    itemId : 'app',
    cache : [],
    items : [{
        itemId : 'panel',
    	xtype : 'panel',
    	layout : 'column',
    	items : [
    	{
            name: 'intervalType',
            xtype: 'combo',
            store : Ext.create("Ext.data.ArrayStore",{
	            fields: ['interval'],
	            data : [['Today'],['This Week'],['Last Week'],['This Month'],['Last Month']]  	
			}),
            valueField : 'interval',
            displayField : 'interval',
            queryMode : 'local',
            forceSelection : true,
            boxLabelAlign: 'after',
            fieldLabel: 'Interval',
            margin: '5 5 5 5',
            listeners : {
                scope : this,
                select : function(list,item) {
                    var panel = _.first(Ext.ComponentQuery.query("#panel"));
                    var startDateCmp = panel.down('#startDate');
                    var endDateCmp = panel.down('#endDate');
                    var start,end;

                    switch(_.first(item).get('interval')){
                        case 'Today' : 
                            start = moment().startOf('day').toDate();
                            end = moment().endOf('end').toDate();
                            break;
                        case 'This Week':
                            start = moment().startOf('week').toDate();
                            end = moment().endOf('week').toDate();
                            break;
                        case 'Last Week':
                            start = moment().subtract(1,'week').startOf('week').toDate();
                            end = moment().subtract(1,'week').endOf('week').toDate();
                            break;
                        case 'This Month':
                            start = moment().startOf('month').toDate();
                            end = moment().endOf('month').toDate();
                            break;
                        case 'Last Month':
                            start = moment().subtract(1,'month').startOf('month').toDate();
                            end = moment().subtract(1,'month').endOf('month').toDate();
                            break;
                    }
                    startDateCmp.setValue( start );startDateCmp.getValue();
                    endDateCmp.setValue( end ); endDateCmp.getValue();
                    // var app = _.first(Ext.ComponentQuery.query("#app"));
                    app._onSelect();
                }
            }
        },
    	{
            itemId : 'startDate',
            margin: '5 5 5 5',
	        xtype: 'datefield',
	        fieldLabel: 'Start Date',
	        value: new Date()
    	},
    	{
            itemId : 'endDate',
            margin: '5 5 5 5',
	        xtype: 'datefield',
	        fieldLabel: 'End Date',
	        value: new Date()
    	},
        {
            itemId : 'exportButton',
            margin: '5 5 5 5',
            xtype: 'rallybutton',
            text : 'Export',
            handler : function() {
                // export
                var grid = app.down("#grid");
                // console.log("grid",grid);
                var link = app.down("#exportLink");
                // console.log("link",link);
                link.update(app.exporter.exportGrid(grid));
            }
        },
        {
            itemId : "exportLink", margin : "12 0 0 10"
        }
    	]
    }],

    launch: function() {

        app = this;

        this._onLoad();
    },

    timeEntryItemColumn : {  
        text: "Time Entry Item", width:100, 
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("TimeEntryItemObject");
            return item ? item.get("WorkProductDisplayString") : "";
       }
    },

    projectColumn : {  
        text: "Project",
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("TimeEntryItemObject");
            return item ? item.get("ProjectDisplayString") : "";
       }
    },

    epicColumn : {  
        text: "Epic",
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("EpicObject");
            return item ? item.get("FormattedID") + ":" + item.get("Name") : "";
       }
    },

    featureColumn : {  
        text: "Feature",
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("FeatureObject");
            return item ? item.get("FormattedID") + ":" + item.get("Name") : "";
       }
    },

    taskColumn : {  
        text: "Task", width:100, 
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("TimeEntryItemObject");
            return item ? item.get("TaskDisplayString") : "";
       }
    },

    userColumn : {  
        text: "User", width:100, 
        renderer : function(value, metaData, record, rowIdx, colIdx, store, view) {
            var item = record.get("TimeEntryItemObject");
            return item ? item.get("User")._refObjectName : "";
       }
    },


	_onLoad: function() {

        app.exporter = Ext.create("GridExporter");

        var cols = [
            { dataIndex : 'DateVal', text: 'Date'},
            app.projectColumn,
            app.timeEntryItemColumn,
            app.taskColumn,
            app.userColumn,
            'Hours',
            'LastUpdated',
            { dataIndex : 'TimeEntryItem', text: 'TimeEntryItem',hidden:true},
            app.epicColumn,
            app.featureColumn
        ];

	    this.add({
	        xtype: 'rallygrid',
            itemId : 'grid',
	        columnCfgs: cols,
	        context: this.getContext(),
	        storeConfig: {
	            model: 'TimeEntryValue'
	        },
            listeners:  {
                load : function(rows) {
                    var values = rows.data.items;
                    // time entry items
                    app.readTimeEntryItems(values).then( {
                        success: function(items) {
                            console.log("items",items);
                            app.setValues(values,items,"TimeEntryItemObject")
                            // stories
                            app.loadStories(items).then({
                                success: function(stories) {
                                    console.log("stories",stories);
                                    app.setValues(values,stories,"StoryObject");
                                    // features
                                    app.readFeatures(stories).then({
                                        success: function(features) {
                                            console.log("features",features);
                                            app.setValues(values,features,"FeatureObject");
                                            // epics
                                            app.readEpics(features).then({
                                                success: function(epics) {
                                                    console.log("epics",epics);
                                                    app.setValues(values,epics,"EpicObject");
                                                }
                                            })
                                        }
                                    })
                                }
                            });
                        }
                    });
                }
            }
	    });
    },

    setValues : function(items, values, attrName) {
        _.each(items,function(item,x){
            item.set(attrName,values[x]);
        });
    },

    // TimesheetEntryItems -> Stories -> Features -> Epics

    readObject : function(model,ref) {

        var deferred = Ext.create('Deft.Deferred');
        var obj = _.find( app.cache, function (cacheObj) {
            if (cacheObj.ref._ref === ref._ref) {
                return cacheObj.promise.promise;
            }
        });

        if (!_.isUndefined(obj)&&!_.isNull(obj)) {
            return obj.promise.promise;
        } else {
            Rally.data.ModelFactory.getModel({
                type : model,
                success: function(model) {
                    model.load(ref,{
                        fetch : true,
                        callback : function(result,operation) {
                            deferred.resolve(result);
                        }
                    })
                }
            })
            app.cache.push({ref : ref, promise: deferred});
            return deferred.promise;
        }
    },

    // passed an array of TimeEntryItems. If the entry is 
    loadStories : function(items) {

        var promises = _.map(items,function(item){
            var deferred = Ext.create('Deft.Deferred');
            var workProductRef = item.get("WorkProduct");
            if (workProductRef===null || workProductRef._type !== "HierarchicalRequirement") {
                deferred.resolve(null);
            }
            else {
                app.readObject('HierarchicalRequirement',workProductRef).then({
                    success : function(obj) {
                        deferred.resolve(obj);
                    }    
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    readTimeEntryItems : function(values) {
        var promises = _.map(values,function(v) {
            var deferred = Ext.create('Deft.Deferred');
            var ref = v.get("TimeEntryItem");

            app.readObject('TimeEntryItem',ref).then({
                success : function(obj) {
                    deferred.resolve(obj);
                }    
            });
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },


    readFeatures : function(stories) {
        var promises = _.map(stories,function(story){
            var deferred = Ext.create('Deft.Deferred');
            if (_.isNull(story) || _.isUndefined(story.get("Feature")) || _.isNull(story.get("Feature"))) {
                deferred.resolve(null);
            } else {
                var featureRef = story.get("Feature");
                app.readObject('PortfolioItem/Feature',featureRef).then({
                    success : function(obj) {
                        deferred.resolve(obj);
                    }    
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);
    },

    readEpics : function(features) {
        var promises = _.map(features,function(feature){
            var deferred = Ext.create('Deft.Deferred');
            if (_.isNull(feature) || _.isUndefined(feature.get("Parent")) || _.isNull(feature.get("Parent")) ) {
                deferred.resolve(null);
            } else {
                var epicRef = feature.get("Parent");
                app.readObject('PortfolioItem/Initiative',epicRef).then({
                    success : function(obj) {
                        deferred.resolve(obj);
                    }    
                });
            }
            return deferred.promise;
        });
        return Deft.Promise.all(promises);        
    },


    _getDateFilter: function() {
        var panel = _.first(Ext.ComponentQuery.query("#panel"));
        var startDateCmp = panel.down('#startDate').getValue();
        var endDateCmp = panel.down('#endDate').getValue();
        var start = Rally.util.DateTime.toIsoString(startDateCmp, false);
        var end   = Rally.util.DateTime.toIsoString(endDateCmp, false);

        return [{
            property: 'DateVal',
            operator: '>=',
            value: start
        },{
            property: 'DateVal',
            operator: '<=',
            value: end
        }];
    },
            
    _onSelect: function() {
        var grid = app.down('rallygrid'),
            store = grid.getStore();

        store.clearFilter(true);
        store.filter(app._getDateFilter());
    },

    _onSelectDate : function(a,b,c) {
        console.log(a,b,c);
    },

    _export: function(){
        var grid = this.down('rallygrid');
        var me = this;

        if ( !grid ) { return; }
        
        this.logger.log('_export',grid);

        var filename = Ext.String.format('user-permissions.csv');

        this.setLoading("Generating CSV");
        Deft.Chain.sequence([
            function() { return Rally.technicalservices.FileUtilities._getCSVFromCustomBackedGrid(grid) } 
        ]).then({
            scope: this,
            success: function(csv){
                if (csv && csv.length > 0){
                    Rally.technicalservices.FileUtilities.saveCSVToFile(csv,filename);
                } else {
                    Rally.ui.notify.Notifier.showWarning({message: 'No data to export'});
                }
                
            }
        }).always(function() { me.setLoading(false); });
    },
});

                Ext.define("GridExporter", {
    //dateFormat : 'Y-m-d g:i',
    dateFormat : 'Y-m-d',

    exportGrid: function(grid) {
        if (Ext.isIE) {
            this._ieToExcel(grid);

        } else {
            var data = this._getCSV(grid);
            // window.location = 'data:text/csv;charset=utf8,' + encodeURIComponent(data);
            return "<a href='data:text/csv;charset=utf8," + encodeURIComponent(data) + "' download='export.csv'>Click to download file</a>";
        }
    },

    _escapeForCSV: function(string) {
        string = "" + string;
        if (string.match(/,/)) {
            if (!string.match(/"/)) {
                string = '"' + string + '"';
            } else {
                string = string.replace(/,/g, ''); // comma's and quotes-- sorry, just loose the commas
            }
        }
        return string;
    },

    _getFieldText: function(fieldData,record,col,index) {
        var text;

        console.log(col);

        // User Hours   Last Updated    Epic    Feature
        if (!_.isUndefined(col) && col.text === "Project")
            return record.get("TimeEntryItemObject").get("Project")._refObjectName;
        // Time Entry Item Task    User    Hours   Last Updated    Epic    Feature
        if (!_.isUndefined(col) && col.text === "Time Entry Item")
            return record.get("TimeEntryItemObject").get("WorkProductDisplayString");
        if (!_.isUndefined(col) && col.text === "Task")
            return record.get("TimeEntryItemObject").get("TaskDisplayString");
        if (!_.isUndefined(col) && col.text === "User")
            return record.get("TimeEntryItemObject").get("User")._refObjectName;
        if (!_.isUndefined(col) && col.text === "Epic")
            return record.get("EpicObject") ? record.get("EpicObject").get("FormattedID") + ":" + record.get("EpicObject").get("Name") : "" ;
        if (!_.isUndefined(col) && col.text === "Feature")
            return record.get("FeatureObject") ? record.get("FeatureObject").get("FormattedID") + ":" + record.get("FeatureObject").get("Name") : "" ;

        if (col && col.renderType === "renderTotalComponentValuePreliminaryEstimate") {
            text = app.renderer.renderTotalComponentValuePreliminaryEstimate (fieldData,0,record,0,index);
            return text;
        }

        if (fieldData == null || fieldData == undefined) {
            text = '';

        } else if (fieldData._refObjectName && !fieldData.getMonth) {
            text = fieldData._refObjectName;

        } else if (fieldData instanceof Date) {
            text = Ext.Date.format(fieldData, this.dateFormat);

        } /*else if (!fieldData.match) { // not a string or object we recognize...bank it out
            text = '';
        } */ else {
            text = fieldData;
        }

        return text;
    },

    _getFieldTextAndEscape: function(fieldData,record,col,index) {
        var string  = this._getFieldText(fieldData,record,col,index);

        return this._escapeForCSV(string);
    },

    // have to add the colIdx to the count of locked columns
    fixedColumnCount : function(columns) {
        var cols = _.filter(columns,function(c) { 
            return c!==undefined && c!==null && c.locked == true;
        });
        return cols.length;
    },

    _getCSV: function (grid) {
        var cols    = grid.columns;
        var store   = grid.store;
        var data    = '';
        console.log("cols",cols);
        // this.fixedCols = this.fixedColumnCount(cols);

        // // creates a sorted index for the header fields, complicated because 
        // // we dont want to sort the fixed columns.
        // var createHeaderIndex = function( cols, fixedColsCount ) {
        //     console.log("fixedColsCount",fixedColsCount);

        //     var headerIndex = _.object( _.pluck(cols,"text"), _.range(cols.length));
        //     console.log("headerIndex",headerIndex);

        //     var keys = _.keys(headerIndex);
        //     console.log("keys",keys);

        //     var fixed = keys.slice(0,fixedColsCount);
        //     console.log("fixed",fixed);

        //     var variable = keys.slice(fixedColsCount).sort();
        //     console.log("variable",variable);

        //     var sortedKeys = _.union(fixed,variable);

        //     console.log("sortedKeys",sortedKeys);

        //     var values = _.map( sortedKeys, function (key) {
        //         return headerIndex[key];
        //     });

        //     console.log("values",values);

        //     var index = _.object( sortedKeys, values);
        //     console.log("index",index);
            
        //     return index;

        // };

        // var sortCols = function( cols, fixedColsCount) {

        //     var fixed = cols.slice(0,fixedColsCount);
        //     var variable = cols.slice(fixedColsCount);
        //     variable = _.sortBy( variable, "text");
        //     var sortedCols = _.union( fixed,variable);
        //     return sortedCols;

        // };

        // var headerIndex = createHeaderIndex(cols, this.fixedCols);
        // var sortedCols = sortCols(cols,this.fixedCols);

        var that = this;
        Ext.Array.each(cols, function(col, index) {
        // Ext.Array.each(sortedCols, function(col, index) { 
            if (col.hidden != true) {
                // fix the issue with the "SYLK" warning in excel by prepending "Item" to the ID column
                var colLabel = (index === 0 ? "Item " : "") + col.text;
                colLabel = colLabel.replace(/<br\/?>/,'');
                data += that._getFieldTextAndEscape(colLabel) + ',';
            }
        });
        data += "\n";

        _.each( store.data.items, function(record) {

            Ext.Array.each(cols, function(col, index) {
            // Ext.Array.each(sortedCols, function(col) {

                // var index = headerIndex[col.text];
            
                if (col.hidden != true) {
                    var fieldName   = col.dataIndex;
                    var text        = record.get(fieldName);
                    data += that._getFieldTextAndEscape(text,record,col,index) + ',';
                }
            });
            data += "\n";
        });

        return data;
    },

    _ieGetGridData : function(grid, sheet) {
        var that            = this;
        var resourceItems   = grid.store.data.items;
        var cols            = grid.columns;

        Ext.Array.each(cols, function(col, colIndex) {
            if (col.hidden != true) {
                
                sheet.cells(1,colIndex + 1).value = col.text;
            }
        });

        var rowIndex = 2;
        grid.store.each(function(record) {
            var entry   = record.getData();

            Ext.Array.each(cols, function(col, colIndex) {
                if (col.hidden != true) {
                    var fieldName   = col.dataIndex;
                    var text        = entry[fieldName];
                    var value       = that._getFieldText(text);

                    sheet.cells(rowIndex, colIndex+1).value = value;
                }
            });
            rowIndex++;
        });
    },

    _ieToExcel: function (grid) {
        if (window.ActiveXObject){
            var  xlApp, xlBook;
            try {
                xlApp = new ActiveXObject("Excel.Application"); 
                xlBook = xlApp.Workbooks.Add();
            } catch (e) {
                Ext.Msg.alert('Error', 'For the export to work in IE, you have to enable a security setting called "Initialize and script ActiveX control not marked as safe" from Internet Options -> Security -> Custom level..."');
                return;
            }

            xlBook.worksheets("Sheet1").activate;
            var XlSheet = xlBook.activeSheet;
            xlApp.visible = true; 

           this._ieGetGridData(grid, XlSheet);
           XlSheet.columns.autofit; 
        }
    }
});

            Rally.launchApp('CustomApp', {
                name:"portfolio-timesheet-export",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
